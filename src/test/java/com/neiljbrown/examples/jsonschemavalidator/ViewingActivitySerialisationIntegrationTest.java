/*
 * Copyright 2014-present the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.neiljbrown.examples.jsonschemavalidator;

import static org.assertj.core.api.Assertions.assertThat;

import java.io.IOException;
import java.io.InputStream;
import java.time.ZonedDateTime;
import java.time.format.DateTimeFormatter;
import java.util.ArrayList;
import java.util.List;

import org.json.JSONException;
import org.junit.Before;
import org.junit.Test;
import org.skyscreamer.jsonassert.JSONAssert;

import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonInclude.Include;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.SerializationFeature;
import com.fasterxml.jackson.datatype.jsr310.JavaTimeModule;
import com.fasterxml.jackson.datatype.jsr310.ser.ZonedDateTimeSerializer;
import com.github.fge.jsonschema.core.exceptions.ProcessingException;
import com.github.fge.jsonschema.core.report.ProcessingReport;
import com.github.fge.jsonschema.main.JsonSchema;
import com.github.fge.jsonschema.main.JsonSchemaFactory;
import com.neiljbrown.examples.jsonschemavalidator.integration.dto.FeedbackDto;
import com.neiljbrown.examples.jsonschemavalidator.integration.dto.ViewingActivityDto;

/**
 * Tests serialisation of Viewing Activity to its canonical (JSON) representation, as per messaging spec.
 * <p>
 * This test case serves as an example of how to test that JSON generated by a component, such as a message producer,
 * adheres to a published <a href="http://json-schema.org/">JSON Schema</a>, and also how to test that the schema itself
 * is a valid JSON Schema.
 */
public class ViewingActivitySerialisationIntegrationTest {

  private static final String JSON_SCHEMA_PATH = "/message-schema/viewingActivity.json";

  /** Factory for creating instances of {@link JsonSchema} which are used to support JSON schema validation */
  private JsonSchemaFactory jsonSchemaFactory;

  /** Instance of {@link ObjectMapper} used to serialise Viewing Activity, with any specialised configuration. */
  private ObjectMapper objectMapper;

  @Before
  public void setUp() throws Exception {
    createObjectMapper();
    this.jsonSchemaFactory = JsonSchemaFactory.byDefault();
  }

  /**
   * Tests that the <a href="http://json-schema.org/">JSON Schema</a> that serves as the official specification of the
   * JSON representation of the {@link ViewingActivityDto Viewing Activity} is a valid JSON schema. This entails
   * checking it is well-formed JSON and also that any recognised fields in a JSON Schema have valid, supported values,
   * e.g. "type" fields should only specifiy valid JSON types.
   * 
   * @throws Exception If an unexpected error occurs.
   */
  @Test
  public final void jsonSchemaIsValid() throws Exception {
    JsonNode schemaJsonNode = readAndDeserialiseJsonSchema();
    ProcessingReport report = this.jsonSchemaFactory.getSyntaxValidator().validateSchema(schemaJsonNode);
    assertThat(report.isSuccess()).withFailMessage(
        "JSON Schema for Viewing Activity [%s] is invalid. Errors [%s].", JSON_SCHEMA_PATH, report).isTrue();
  }

  /**
   * Tests serialising an instance of {@link ViewingActivityDto} that is only populated with those fields which are
   * defined as mandatory in the schema for the JSON representation of the message. Serves to check, for example that
   * unpopulated (null) properties are _not_ serialised as "null" values.
   * <p>
   * Includes checking that the generated JSON conforms to the published JSON Schema for Viewing Activity.
   * 
   * @throws Exception If an unexpected error occurs.
   */
  @Test
  public final void serialiseMinimalViewingActivity() throws Exception {
    String receivedDateTimeString = "2016-07-08T19:32:58.123Z";
    List<FeedbackDto> feedbacks = new ArrayList<>(1);
    FeedbackDto feedback = new FeedbackDto(3);
    feedbacks.add(feedback);
    ViewingActivityDto viewingActivity = new ViewingActivityDto(receivedDateTimeString, feedbacks);

    String json = this.objectMapper.writeValueAsString(viewingActivity);

    assertJson(json, "{ "
        + "\"received\": \"" + receivedDateTimeString + "\", "
        + "\"feedbacks\": [ { \"rating\":" + feedback.getRating() + "} ]"
        + "}");

    assertJsonConformsToSchema(json);
  }

  /**
   * Asserts that the actual, generated JSON conforms to the JSON Schema for Viewing Activity.
   * <p>
   * Serves to additionally check that the JSON adheres to constraints defined in the schema such as required fields,
   * min/max no. of elements, and field value restrictions such as enums and patterns.
   * 
   * @param actualJson
   * @throws ProcessingException
   * @throws IOException
   * @throws JsonProcessingException
   */
  private void assertJsonConformsToSchema(String actulaJson)
      throws ProcessingException, IOException, JsonProcessingException {
    JsonSchema jsonSchema = this.jsonSchemaFactory.getJsonSchema(readAndDeserialiseJsonSchema());
    JsonNode jsonNode = this.objectMapper.readTree(actulaJson);
    ProcessingReport report = jsonSchema.validate(jsonNode, true);
    assertThat(report.isSuccess()).withFailMessage(
        "Generated JSON [%s] does not conform to schema [%s]. Schema validation errors [%s]", jsonNode,
        JSON_SCHEMA_PATH, report).isTrue();
  }

  /**
   * Asserts that the actual generated JSON is _semantically_ equal to the expected JSON, ignoring any insignificant
   * differences, such as the order of fields, in cases where this doesn't matter. Performs the equivalent of XMLUnit
   * asserts for JSON.
   * 
   * @param actual The actual JSON string.
   * @param expected The expected JSON string.
   */
  private void assertJson(String actual, String expected) {
    try {
      JSONAssert.assertEquals(expected, actual, true);
    } catch (JSONException e) {
      throw new RuntimeException("JSON assert encountered malformed JSON [" + e.toString() + "].", e);
    }
  }

  private JsonNode readAndDeserialiseJsonSchema() throws IOException {
    InputStream is = this.getClass().getResourceAsStream(JSON_SCHEMA_PATH);
    return this.objectMapper.readTree(is);
  }

  /**
   * Creates an instance of Jackson {@link ObjectMapper} and configures its serialisation behaviour to what's required
   * when serialising viewing activity.
   * 
   * @return The configured instance of {@link ObjectMapper}.
   */
  private void createObjectMapper() {
    this.objectMapper = new ObjectMapper()
        // Enable out-of-box support for serialising Java 8 java.time classes as date/time strings
        .registerModule(createJacksonJavaTimeModule())
        // Disable serialisation of empty collections/arrays (as empty JSON arrays) by default
        .setSerializationInclusion(JsonInclude.Include.NON_EMPTY)
        // Disable serialisation of null properties (as "null") by default
        .setSerializationInclusion(Include.NON_NULL)
        // Disable serialisaiton of Java date/times to numeric timestamps, use formatted strings (patterns) by default
        .disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS)
        // pretty-print output JSON
        .enable(SerializationFeature.INDENT_OUTPUT);
  }

  /**
   * Creates and configures an instance of the optional Jackson module that provides support for parsing and formatting
   * when de/serialising Java 8 java.time classes, for registration with Jackson ObjectMapper.
   * <p>
   * Method exists to apply some non-default configuration to the module.
   */
  private JavaTimeModule createJacksonJavaTimeModule() {
    JavaTimeModule module = new JavaTimeModule();
    // Override the default instance of ZonedDateTimeSerializer used by Jackson with one which uses a supplied instance
    // of J8 DateTimeFormatter to ensure serialised ZonedDateTime always include fractional milliseconds even when zero.
    // In Jackson 2.8.x+ the default instance of ZonedDateTimeSerializer uses DateTimeFormatter.ISO_OFFSET_DATE_TIME
    // which does not print the milliseconds if they're zero. For more details see
    // https://github.com/FasterXML/jackson-datatype-jsr310/issues/39 and
    // http://stackoverflow.com/questions/35184481/java-8-datetimeformatter-dropping-millis-when-theyre-zero/35184630#35184630
    module.addSerializer(ZonedDateTime.class,
        new ZonedDateTimeSerializer(DateTimeFormatter.ofPattern("yyyy-MM-dd'T'HH:mm:ss.SSSX")));
    return module;
  }
}